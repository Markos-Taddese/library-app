const db=require('../config/database')
async function getBooks(req,res,next){
  try{ 
    //left join for cases like thers book title but no physical copy is recorded
    //counted both physical copies and available out of those copies 
    const [result]= await db.query(`SELECT 
  b.book_id, 
  b.title, 
  a.author_name as author,
  b.published_year, 
  COUNT(bc.copy_id) AS total_copies,
  COUNT(CASE WHEN bc.status = 'available' THEN 1 END) AS available_copies,
  -- Add this: get first available copy_id for deletion
  MIN(CASE WHEN bc.status = 'available' THEN bc.copy_id END) AS sample_copy_id
FROM books b
INNER JOIN authors a on b.author_id=a.author_id
LEFT JOIN book_copies bc on b.book_id=bc.book_id
GROUP BY b.book_id, b.title, b.published_year, a.author_name
ORDER BY b.title ASC;
 `)
       // Return 200 status. The results array is wrapped in an object 
        // with the 'books' key for consistent API structure.
    if (result.length === 0) {
            return res.status(200).json({
                success: true,
                message: 'No books have been added yet.',
                books: []
            });
        }
       res.status(200).json({
        success:true,
        books:result});}
    catch(error){
       next(error)
    }
}
async function saveBooks(req,res,next){
  let connection;
try{    
  const {title,author,published_year}=req.body
  //validate if the required inputs were provided
  if (!title || !author) {
      const err=new Error('Title and Author are required to add a book.' )
      err.statusCode=400;
      return next(err);
  }
connection= await db.getConnection();
await connection.beginTransaction();
  let yearValue;
  if (published_year === "" || published_year === undefined || published_year === null) {
       yearValue = null; 
  } else {
 // If it's anything else (like a valid number or an invalid string like "NotAYear"),
 // we first attempt to convert it to an integer.
  const parsedYear = parseInt(published_year);
 // If the conversion results in NaN, we also treat it as null.
    if (isNaN(parsedYear)) {
        yearValue = null;
    } else {
       yearValue = parsedYear;
       }
      }
let authorId;
const[resultAuthor]=await connection.query(`SELECT * FROM authors where author_name=?`,[author])
if(resultAuthor.length>0){
  // Author exists: get the existing ID
  authorId=resultAuthor[0].author_id
}  else{
  // Author does not exist: insert the new author and get the new ID
 const[insertResultAuthor]=await connection.query(`INSERT INTO authors (author_name) VALUES(?)`,[author])
 authorId=insertResultAuthor.insertId
}
let bookId;
// Check if the title already exists for this author
const[resultBook]=await connection.query(`SELECT * FROM books WHERE title=? and author_id=?`,[title,authorId])
if(resultBook.length>0){
  // Title exists: get the existing ID (so a copy is being added, not a new title)
  bookId=resultBook[0].book_id
}
else{
  // Title does not exist: insert the new title into the 'books' table
const[insertResultBook]=await connection.query(`INSERT INTO books (title,author_id,published_year) 
                                       VALUES(?,?,?)`,[title,authorId,yearValue])
  bookId=insertResultBook.insertId
}
//insert a new entry into the book_copies table to track the physical item.
const[insertCopyResult]=await connection.query(`INSERT INTO book_copies(book_id,status) 
                                               VALUES(?,?)`,[bookId,'available']);
    
    await connection.commit();
    res.status(201).json({
    success:true,
    message:"book saved successfully",
    book_id: bookId,
    copy_id:insertCopyResult.insertId//the id generated by the database autocinrement
    });
  }
    catch(error){
    //if the error happens while there's a database connection
      if(connection){
    await connection.rollback();
    return next(error)
      }
    // and if the error is happen bc theres no connection of database at the momemnt/ was never made
        const err=new Error('Database connection failed. Unable to process request.')
          err.statusCode=503;
          return next(err)
    }  
 finally{
      if(connection){
        connection.release();
      }
    }
} 
 async function getDetailBook(req, res, next) {
try {
const id = req.params.id;
if (!id) {
const err = new Error('Book ID is required in the URL path.');
err.statusCode = 400;
return next(err);
}
const [result] = await db.query(`SELECT b.book_id,b.title,b.published_year,a.author_name AS author,
                                  COUNT(bc.copy_id) AS total_copies,
                                  COUNT(CASE WHEN bc.status = 'available' THEN 1 END) AS available_copies
                                  FROM books b
                                  INNER JOIN authors a ON b.author_id = a.author_id
                                  LEFT JOIN book_copies bc ON b.book_id = bc.book_id
                                  WHERE b.book_id = ? GROUP BY b.book_id, b.title, b.published_year, a.author_name`, [id]);
// 404 Not Found Check
if (result.length === 0) {
const err = new Error(`Book with ID ${id} not found.`);
err.statusCode = 404;
return next(err);
}
res.status(200).json({
success: true,
book: result[0]
});
} catch (error) {
next(error);
}

}
async function deleteBooks(req,res,next){
try{  
  console.log('Delete ID:', req.params.id);
const copyId=req.params.id
if (!copyId) {
            const err=new Error(`Book's copy ID is required for deletion.`)
            err.statusCode=400;
            return next(err)
        }
connection= await db.getConnection();
await connection.beginTransaction();
// Get the book_id and author_id related to this copy before deleting it.
const[copyInfo]=await connection.query(`SELECT b.book_id, b.author_id,bc.status
                                        FROM book_copies bc
                                        INNER JOIN books b ON bc.book_id=b.book_id
                                        WHERE bc.copy_id=? FOR UPDATE `,[copyId])
if(copyInfo.length===0){
  await connection.rollback()
  const err = new Error(`Book's Copy with ID ${copyId} not found.`);
  err.statusCode = 404;
  return next(err);
}
const { status, book_id, author_id } = copyInfo[0];
  // If the copy is currently loaned, we must prevent the physical delete.
if (status !== 'available') {
await connection.rollback();
const err = new Error(`Cannot delete copy ID ${copyId}. 
  It is currently marked as '${status}' and must be returned first.`);
err.statusCode = 409; // Conflict
return next(err);
        }
await connection.query('DELETE FROM book_copies where copy_id=?',[copyId]);
//Check for Remaining Copies 
const[copiesLeft]=await connection.query(`SELECT COUNT(*) AS count 
                                         FROM book_copies WHERE book_id=?`,[book_id])
let authorRemoved=false;//boolean flag forlater use
if(copiesLeft[0].count===0){
// If no copies left, DELETE the book title.
await connection.query('DELETE FROM books WHERE book_id = ?', [book_id]);
//  Check for Remaining Books by the Author.
const[booksLeft]=await connection.query(`SELECT COUNT(*) AS count 
                                        FROM books where author_id=?`,[author_id])
if(booksLeft[0].count===0){
//If no books left, DELETE the author record.
await connection.query(`DELETE FROM authors where author_id=?`,[author_id])
authorRemoved=true;
}
}
await connection.commit()
let message=`Book's Copy ID ${copyId} deleted`
if (copiesLeft[0].count === 0) {
    message += " - Book title removed (no copies left)";
    //bookleft is invisible for this block so we use our flag
if (authorRemoved) {
        message += " - Author removed (no books left)";
    }
}
 res.status(200).json({
  success:true,
  message
    });
 }
  catch(error){
    //if the error happens while there's a database connection
      if(connection){
   await connection.rollback();
   // Handle Foreign Key Constraint Violation (e.g., Book has active loans in 'loans' table).
  // The error code ER_ROW_IS_REFERENCED is specific to MySQL and indicates related records exist.
 return next(error)
      }
    // and if the error is happen bc theres no connection of database at the momemnt/ was never made
        const err=new Error('Database connection failed. Unable to process request.')
          err.statusCode=503;
          return next(err)
    }  
 finally{
      if(connection){
        connection.release();
      }
    }
}
async function updateBooks(req, res,next){
try{    
  const id = req.params.id;
    const updates = req.body;
    if (!id || Object.keys(updates).length === 0) {
          const err=new Error('Book ID and update data are required.')
          err.statusCode=400;
          return next(err);
        }
connection = await db.getConnection();
await connection.beginTransaction();
// Get the current author_id for cleanup later
const [[currentBookInfo]] = await connection.query('SELECT author_id FROM books WHERE book_id = ?', [id]);
if (currentBookInfo.length === 0) {
  await connection.rollback()
const err = new Error(`Book with ID ${id} not found.`);
err.statusCode = 404;
return next(err);
  }
const oldAuthorId=currentBookInfo.author_id;
const cleanedUpdates = {};
let newAuthorId = oldAuthorId;
let authorIdChanged = false;
const authorNameUpdate = updates.author_name;
for (const [key, value] of Object.entries(updates)) {
    // Default handling for all fields (Handles "", undefined, null)
    let finalValue = (value === "" || value === undefined || value === null) ? null : value;
    if (key === 'title' && finalValue === null) {
      await connection.rollback()
        // If title is required but is now NULL, throw error immediately
        const err = new Error('The book title is required and cannot be empty.');
        err.statusCode = 400;
       return next(err); 
    }
     if (key === 'author_name' && finalValue === null) {
      await connection.rollback()
    // If author_name is sent but is empty/null, treat it as an immediate error
    const err = new Error('The author name is required and cannot be empty.');
    err.statusCode = 400;
    return next(err); 
}
    //Apply integer safety check ONLY to published_year
    if (key === 'published_year' && finalValue !== null) {
        const parsedYear = parseInt(finalValue);
    //If the input was a garbage string, set to null.
        finalValue = isNaN(parsedYear) ? null : parsedYear;
    }
   
    if(key!=='author_name'){ 
     cleanedUpdates[key] = finalValue;
    }
}
if(authorNameUpdate !== undefined && authorNameUpdate !== null && authorNameUpdate !== ""){
  const[result]=await connection.query(`SELECT author_id FROM authors WHERE author_name=?`,
                                     [authorNameUpdate])
  if(result.length>0){
    newAuthorId = result[0].author_id;
  }
  else {
// If not found, INSERT the new author and get the ID
  const [insertResult] = await connection.query('INSERT INTO authors (author_name) VALUES (?)', 
                                              [authorNameUpdate]);
  newAuthorId = insertResult.insertId;
  }
  // If the ID is different from the original, add it to the update queue
if (newAuthorId !== oldAuthorId) {
cleanedUpdates.author_id = newAuthorId;
authorIdChanged = true;
  }
}
if (Object.keys(cleanedUpdates).length === 0) {
await connection.commit();
return res.status(200).json({ 
  success: true, 
  message: "Update successful (no changes were needed)." 
});
        }
    // Build SET clause dynamically
    const setClause = Object.keys(cleanedUpdates).map(key => `${key} = ?`).join(', ');
    const values = Object.values(cleanedUpdates);
    values.push(id);

    const [result] = await connection.query(
        `UPDATE books SET ${setClause} WHERE book_id = ?`,
        values
    );
  let message="Book update successfully applied"
if (authorIdChanged) {
  // Check if the old author is now dont have any book left
const [result] = await connection.query(
'SELECT COUNT(*) AS count FROM books WHERE author_id = ?', 
[oldAuthorId]
);
// If the count is zero, DELETE the redundant author record.
  if (result[0].count === 0) {
      await connection.query('DELETE FROM authors WHERE author_id = ?', [oldAuthorId]);
      message+=" and unused author removed"
     }
     else{
      message+=" and author reference updated";
     }
  }
  await connection.commit();
res.status(200).json({ success: true, message });
  }
catch(error){
  if(connection){
  await connection.rollback();
 return next(error)
      }
const err=new Error('Database connection failed. Unable to process request.')
err.statusCode=503;
return next(err)
    }  
 finally{
      if(connection){
        connection.release();
      }
    }
}
async function searchBooks(req, res, next) {
  try {  
    const { search, available } = req.query;
    
    // FIX: Add sample_copy_id to search results
    let query = `SELECT b.book_id, b.title, a.author_name, b.published_year,
                        COUNT(bc.copy_id) AS total_copies,
                        COUNT(CASE WHEN bc.status = 'available' THEN 1 END) AS available_copies,
                        MIN(CASE WHEN bc.status = 'available' THEN bc.copy_id ELSE NULL END) AS sample_copy_id
                 FROM books b
                 INNER JOIN authors a ON b.author_id = a.author_id
                 LEFT JOIN book_copies bc ON b.book_id = bc.book_id
                 WHERE 1=1`;
    
    let params = [];
    
    if (search) {
      query += ' AND (b.title LIKE ? OR a.author_name LIKE ?)';
      params.push(`%${search}%`, `%${search}%`);
    }
    
    query += ` GROUP BY b.book_id, b.title, b.published_year, a.author_name`;
    
    if (available) {
      query += ` HAVING available_copies > 0`;
    }
    
    const [results] = await db.query(query, params);
    
    if (results.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No books matched your search criteria.',
        books: []
      });
    }
    
    res.json({
      success: true,
      count: results.length,
      books: results
    });
  }
  catch(error) {
    next(error)
  }
}

async function getBookStats(req, res, next) {
try {
  const [totalBooksResult] = await db.query('SELECT COUNT(*) as total FROM books');
  const totalBooks = totalBooksResult[0].total;
//Get Total Number of Available Copies (from book_copies table)
  const [availableCopiesResult] = await db.query(
  "SELECT COUNT(*) as available FROM book_copies WHERE status = 'available'"
        );
  const availableCopies = availableCopiesResult[0].available;
   res.status(200).json({
    success: true,
    total_unique_books: totalBooks, 
    total_available_copies: availableCopies,
  });
} 
catch(error) {
next(error);
    }
}

module.exports= {
  getDetailBook,
  getBooks,
  saveBooks,
  deleteBooks,
  updateBooks,
  getBookStats,
  searchBooks
}