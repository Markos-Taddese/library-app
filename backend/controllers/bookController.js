const db=require('../config/database')
async function getBooks(req,res,next){
  try{  
    const [result]= await db.query('select * from books')
       // Return 200 status. The results array is wrapped in an object 
        // with the 'books' key for consistent API structure.
    if (result.length === 0) {
            return res.status(200).json({
                success: true,
                message: 'No books have been added yet.',
                books: []
            });
        }
       res.status(200).json({
        success:true,
        books:result});}
    catch(error){
       next(error)
    }
}
async function saveBooks(req,res,next){
try{    
  const {title,author,published_year}=req.body
  //validate if the required inputs were provided
  if (!title || !author) {
            const err=new Error('Title and Author are required to add a book.' )
            err.statusCode=400;
            return next(err);
        }
        let yearValue;
        if (published_year === "" || published_year === undefined || published_year === null) {
            yearValue = null; 
        } else {
            // If it's anything else (like a valid number or an invalid string like "NotAYear"),
            // we first attempt to convert it to an integer.
            const parsedYear = parseInt(published_year);
            
            // If the conversion results in NaN, we also treat it as null.
            if (isNaN(parsedYear)) {
                yearValue = null;
            } else {
                yearValue = parsedYear;
            }
        }
    const[result]=await db.query(`insert into books (title,author,published_year) 
                                              values(?,?,?)`,
                                 [title,author,yearValue]);
    res.status(201).json({
    success:true,
    message:"book saved successfully",
    book_id: result.insertId //the id generated by the database autocinrement
    });
  }
  catch(error){
    //Catch any database or server execution errors.
    next(error)
  }
} 
 async function getDetailBook(req, res, next) {
try {
const id = req.params.id;
if (!id) {
const err = new Error('Book ID is required in the URL path.');
err.statusCode = 400;
return next(err);
}
const [result] = await db.query('SELECT * FROM books WHERE book_id = ?', [id]);
// 404 Not Found Check
if (result.length === 0) {
const err = new Error(`Book with ID ${id} not found.`);
err.statusCode = 404;
return next(err);
}
res.status(200).json({
success: true,
book: result[0]
});
} catch (error) {
next(error);
}

}
async function deleteBooks(req,res,next){
try{  
  console.log('Delete ID:', req.params.id);
const id=req.params.id
if (!id) {
            const err=new Error('Book ID is required for deletion.')
            statusCode=400;
            return next(err)
        }
const [result]=await db.query('delete from books where book_id=?',[id]);
if(result.affectedRows>0){
    res.status(200).json({
      success:true,
      message:"Book removed succesfully"
    })
}
else{
  const err = new Error(`Book with ID ${id} not found.`);
  err.statusCode=404;
  return next(err)
}
 }
catch(error){
  // Handle Foreign Key Constraint Violation (e.g., Book has active loans in 'loans' table).
  // The error code ER_ROW_IS_REFERENCED is specific to MySQL and indicates related records exist.
 next(error)
  }
}
async function updateBooks(req, res,next){
try{    
  const id = req.params.id;
    const updates = req.body;
    if (!id || Object.keys(updates).length === 0) {
          const err=new Error('Book ID and update data are required.')
          err.statusCode=400;
          return next(err);
        }
        const [[{ count }]] = await db.query('SELECT COUNT(*) as count FROM books WHERE book_id = ?', [id]);
        if (count === 0) {
            const err = new Error(`Book with ID ${id} not found.`);
            err.statusCode = 404;
            return next(err);
        }
        const cleanedUpdates = {};
for (const [key, value] of Object.entries(updates)) {
    // Default handling for all fields (Handles "", undefined, null)
    let finalValue = (value === "" || value === undefined || value === null) ? null : value;
    //Apply integer safety check ONLY to published_year
    if (key === 'published_year' && finalValue !== null) {
        const parsedYear = parseInt(finalValue);
    //If the input was a garbage string, set to null.
        finalValue = isNaN(parsedYear) ? null : parsedYear;
    }
    cleanedUpdates[key] = finalValue;
}
    // Build SET clause dynamically
    const setClause = Object.keys(cleanedUpdates).map(key => `${key} = ?`).join(', ');
    const values = Object.values(cleanedUpdates);
    values.push(id);

    const [result] = await db.query(
        `UPDATE books SET ${setClause} WHERE book_id = ?`,
        values
    );
if(result.affectedRows>0){
    res.status(200).json({
      success:true,
      message:"update succesfully added"})
}
else{
// Record existed (checked above), but affectedRows is 0 because nothing changed
            return res.status(200).json({
                success: true,
                message: "Update successful (no new changes were needed)."
                });
}
  }
catch(error){
   next(error)
  }
}
async function searchBooks(req, res,next) {
try{  
  const { search, available } = req.query;
 // Initialize the base query. 'WHERE 1=1' allows for easy, conditional addition 
        // of subsequent 'AND' clauses without complex initial checks.
  let query = 'SELECT * FROM books WHERE 1=1';
  let params = [];
  //filter for title and/or author
  if (search) {
    query += ' AND (title LIKE ? OR author LIKE ?)';
    params.push(`%${search}%`, `%${search}%`);
  }
  //filter for availabilty
  if (available) {
    query += ' AND available = ?';
    params.push(available === 'true');
  }
  const [result] = await db.query(query, params);
  if (result.length === 0) {
    return res.status(200).json({
        success: true,
        message: 'No books matched your search criteria.',
        books: []
    });
}
    res.json({
      success:true,
      books:result});
  }
  catch(error){
    //internal error
  next(error)
  }
}

async function getBookStats(req, res,next) {
  try{
    const [result] = await db.query('SELECT COUNT(*) as total, SUM(available) as available FROM books');
  res.status(200).json({
            success: true,
            total_members: result[0].total 
        });
}
catch(error){
next(error)
}
}

module.exports= {
  getDetailBook,
  getBooks,
  saveBooks,
  deleteBooks,
  updateBooks,
  getBookStats,
  searchBooks
}